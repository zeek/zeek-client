#! /usr/bin/env python3
"""
This is a prototypical implementation of a Zeek management client, as sketched
in the following architecture design doc:

https://docs.google.com/document/d/1r0wXnihx4yESOpLJ87Wh2g1V-aHOFUkbgiFe8RHJpZo/edit

Work on this client is currently in progress and maturing over the course of
the Zeek 4.x series. Feedback is welcome. This implementation adopts many of
the idioms and primitives also used by the zkg package manager.
"""
# https://pypi.org/project/argcomplete/#global-completion
# PYTHON_ARGCOMPLETE_OK

# pylint: disable=invalid-name, missing-function-docstring, too-few-public-methods
# pylint: disable=too-many-instance-attributes, too-many-arguments, no-self-use

# Broker lessons learned:
#
# - When sending an event from Python results in an error message like the
#   following on the Zeek side ...
#
#     warning: failed to convert remote event '<some event type>' arg #<n>,
#         got vector, expected record
#
#   ... the reason is that some member of the structure in question (here,
#   a record) could not be unserialized properly.

import argparse
import configparser
import enum
import ipaddress
import json
import logging
import os.path
import select
import shlex
import sys
import time
import traceback
import uuid

try:
    # Argcomplete provides command-line completion for users of argparse.
    # We support it if available, but don't complain when it isn't.
    import argcomplete # pylint: disable=import-error
except ImportError:
    pass

LOG = logging.getLogger(__name__)
LOG.addHandler(logging.NullHandler())

ZC_CONTROLLER_HOST = '127.0.0.1'
ZC_CONTROLLER_PORT = '2150'
ZC_CONTROLLER = ZC_CONTROLLER_HOST + ':' + ZC_CONTROLLER_PORT
ZC_CONTROLLER_TOPIC = 'zeek/management/controller'

ZC_VERSION = '@VERSION_MAJOR@.@VERSION_MINOR@.@VERSION_PATCH@'
ZC_CONFIG_FILE = os.getenv('ZEEK_CLIENT_CONFIG_FILE') or '@ZEEK_CLIENT_CONFIG_FILE@'

# Global config, a ClientConfig instance (deriving from ConfigParser).
ZC_CONFIG = None

# Prepend the Python path of the Zeek installation. This ensures we find the
# Zeek-bundled Broker Python bindings, if available, before any system-wide
# ones.
ZEEK_PYTHON_DIR = '@PY_MOD_INSTALL_DIR@'
if os.path.isdir(ZEEK_PYTHON_DIR):
    sys.path.insert(0, os.path.abspath(ZEEK_PYTHON_DIR))

try:
    import broker
except ImportError:
    print('error: zeek-client requires the Python Broker bindings.\n'
          'Make sure your Zeek build includes them. To add installed\n'
          'Broker bindings to Python search path manually, add the\n'
          'output of "zeek-config --python_dir" to PYTHONPATH.')
    sys.exit(1)


class ClientConfig(configparser.ConfigParser):
    """zeek-client configuration settings.

    A specialized ConfigParser that hardwires defaults for select values.
    Three levels of overrides apply, if provided:

    (1) first, the config file, if available

    (2) the ZEEK_CLIENT_CONFIG_SETTINGS environment variable may contain a
        series of <section.key>=<val> assignments

    (3) Any --set <section.key>=<val> arguments apply final overrides
    """
    def __init__(self):
        super().__init__()
        self.read_dict({
            'client': {
                # The default timeout for request state is 15 seconds on the
                # Zeek side, so by making it larger here we ensure that timeout
                # events can fire & propagate in Zeek before we give up here.
                'request_timeout_secs': 20,

                # How long Broker's endpoint.peer() should wait until it retries
                # a peering. Its default is 10 seconds; we dial that down
                # because we retry anyway, per the next setting. 0 disables.
                'connect_peer_retry_secs': 1,

                # How often to attempt peerings within Controller.connect():
                'connect_attempts': 4,

                # Delay between our on connect attempts.
                'connect_retry_delay_secs': 0.25,

                # Whether we pretty-print JSON output by default.
                'pretty_json': True,
            },
        })

    def update_from_file(self, config_file=ZC_CONFIG_FILE):
        self.read(config_file)

    def update_from_env(self):
        for item in shlex.split(os.getenv('ZEEK_CLIENT_CONFIG_SETTINGS') or ''):
            try:
                self.apply(item)
            except ValueError:
                print_error('error: config item "{}" in ZEEK_CLIENT_CONFIG_SETTINGS '
                            'invalid. Please use <section.key>=<val>. See --help.'
                            .format(item))

    def update_from_args(self, args):
        for item in args.set:
            try:
                ZC_CONFIG.apply(item)
            except ValueError:
                print_error('error: config item "{}" invalid. Please use '
                            '<section.key>=<val>. See --help.'.format(item))

    def apply(self, item):
        """This is equivalent to set(), but works via a single <section.key>=<val> string."""
        try:
            identifier, val = item.split('=', 1)
            section, key = identifier.split('.', 1)
            if not self.has_section(section):
                self.add_section(section)
            self.set(section, key, val)
        except ValueError as err:
            raise ValueError('config item "{}" invalid'.format(item)) from err

    def completer(self, **_kwargs):
        """A completer suitable for argcomplete."""
        ret = []

        for section in self.sections():
            for key, val in self.items(section):
                ret.append(section + '.' + key + '=' + val)

        return sorted(ret)

ZC_CONFIG = ClientConfig()


class Event(broker.zeek.SafeEvent):
    """A specialization of Broker's Event class to make it printable, make arguments
    and their types explicit, and allow us to register instances as known event
    types."""
    # XXX at least the printability could go into Broker bindings

    # Contextualize the event: name, argument names, and argument types (in
    # Broker rendition).
    NAME = None
    ARG_NAMES = []
    ARG_TYPES = []

    def __init__(self, *args):
        """Creates a Zeek event object.

        This expects the number of arguments contextualized above. The event
        name is not required since it's defined implicitly via the event class
        receiving the arguments.

        Raises:
            TypeError: when the given arguments, or number of arguments, don't
                match the expected ARG_TYPES or their number.
        """
        if len(args) != len(self.ARG_NAMES):
            raise TypeError('event argument length mismatch: have %d, expected %d'
                            % (len(args), len(self.ARG_NAMES)))
        if len(self.ARG_NAMES) != len(self.ARG_TYPES):
            raise TypeError('number of event argument names and types must match')

        for tpl in zip(args, self.ARG_TYPES, range(len(self.ARG_TYPES))):
            # The data model is permissive regarding list vs tuple, so accept
            # lists in stead of tuple:
            typ0, typ1 = type(tpl[0]), tpl[1]
            if typ1 == list and typ0 == tuple:
                typ0 = list
            if typ0 != typ1:
                raise TypeError('event type mismatch: argument %d is %s, should be %s'
                                % (tpl[2]+1, typ0, typ1))
        args = [self.NAME] + list(args)
        super().__init__(*args)

    def __getattr__(self, name):
        try:
            idx = self.ARG_NAMES.index(name)
            return self.args()[idx]
        except ValueError as err:
            raise AttributeError from err

    def __str__(self):
        # A list of pairs (argument name, typename)
        zeek_style_args = zip(self.ARG_NAMES, [str(type(arg)) for arg in self.args()])
        # That list, with each item now a string "<name>: <typename"
        zeek_style_arg_strings = [': '.join(arg) for arg in zeek_style_args]
        # A Zeek-looking event signature
        return self.name() + '(' + ', '.join(zeek_style_arg_strings) + ')'


class EventRegistry:
    """Functionality for event types and to instantiate events from data."""

    # Map from Zeek-level event names to Event classes. The make_event()
    # function uses this map to instantiate the right event class from
    # received Broker data.
    EVENT_TYPES = {}

    @staticmethod
    def make_event_class(name, arg_names, arg_types):
        """Factory function to generate a Zeek event class.

        Given an event name, event arguments, and corresponding argument types,
        the function generates a new Event class, registers it, and returns it.
        """
        res = type(name, (Event,), {})

        res.NAME = name
        res.ARG_NAMES = arg_names
        res.ARG_TYPES = arg_types

        # Register the new event type
        EventRegistry.EVENT_TYPES[name] = res

        return res

    @staticmethod
    def make_event(args):
        """Transform Broker-level data into Zeek event instance.

        The function takes received Broker-level data, instantiates a
        Broker-level event object from them, and uses the identified name to
        create a new Zeek event instance. Returns None if the event wasn't
        understood.
        """
        evt = broker.zeek.SafeEvent(args)
        args = evt.args()

        if evt.name() not in EventRegistry.EVENT_TYPES:
            LOG.warning('received unexpected event "%s", skipping', evt.name())
            return None

        LOG.debug('received event "%s"', evt.name())
        return EventRegistry.EVENT_TYPES[evt.name()](*args)


class events:
    """A scope to define event types we send/receive."""

    # This could become a module if/when we break apart this script.

    # Any Zeek object/record that's an event argument gets represented as a
    # tuple here, reflecting Broker's representation thereof.

    GetConfigurationRequest = EventRegistry.make_event_class(
        'Management::Controller::API::get_configuration_request',
        ('reqid',), (str,))

    GetConfigurationResponse = EventRegistry.make_event_class(
        'Management::Controller::API::get_configuration_response',
        ('reqid', 'result'), (str, tuple))

    GetIdValueRequest = EventRegistry.make_event_class(
        'Management::Controller::API::get_id_value_request',
        ('reqid', 'id', 'nodes'), (str, str, set))

    GetIdValueResponse = EventRegistry.make_event_class(
        'Management::Controller::API::get_id_value_response',
        ('reqid', 'results'), (str, tuple))

    GetInstancesRequest = EventRegistry.make_event_class(
        'Management::Controller::API::get_instances_request',
        ('reqid',), (str,))

    GetInstancesResponse = EventRegistry.make_event_class(
        'Management::Controller::API::get_instances_response',
        ('reqid', 'result'), (str, tuple))

    GetNodesRequest = EventRegistry.make_event_class(
        'Management::Controller::API::get_nodes_request',
        ('reqid',), (str,))

    GetNodesResponse = EventRegistry.make_event_class(
        'Management::Controller::API::get_nodes_response',
        ('reqid', 'results'), (str, tuple))

    SetConfigurationRequest = EventRegistry.make_event_class(
        'Management::Controller::API::set_configuration_request',
        ('reqid', 'config'), (str, tuple))

    SetConfigurationResponse = EventRegistry.make_event_class(
        'Management::Controller::API::set_configuration_response',
        ('reqid', 'results'), (str, tuple))

    TestNoopRequest = EventRegistry.make_event_class(
        'Management::Controller::API::test_noop_request',
        ('reqid',), (str,))

    TestTimeoutRequest = EventRegistry.make_event_class(
        'Management::Controller::API::test_timeout_request',
        ('reqid', 'with_state'), (str, bool))

    TestTimeoutResponse = EventRegistry.make_event_class(
        'Management::Controller::API::test_timeout_response',
        ('reqid', 'result'), (str, tuple))


class Controller:
    """A class representing our Broker connection to the Zeek cluster controller."""
    def __init__(self, controller_host, controller_port,
                 controller_topic=ZC_CONTROLLER_TOPIC):
        self.controller_host = controller_host
        self.controller_port = controller_port
        self.controller_topic = controller_topic
        self.ep = broker.Endpoint()
        self.sub = self.ep.make_safe_subscriber(controller_topic)
        self.ssub = self.ep.make_status_subscriber(True)

        self.poll = select.poll()
        self.poll.register(self.sub.fd())
        self.poll.register(self.ssub.fd())

    def connect(self):
        # We add retries around Broker's peering because some problems don't
        # fall under its built-in retry umbrella. Our explicit retries simplify
        # testing setups, where they mask the bootstrapping of the services
        # involved.
        attempts = ZC_CONFIG.getint('client', 'connect_attempts')
        for i in range(attempts):
            self.ep.peer_nosync(self.controller_host, self.controller_port,
                                ZC_CONFIG.getfloat('client', 'connect_peer_retry_secs'))

            # Wait for outcome of the peering attempt:
            status = self.ssub.get()
            if isinstance(status, broker.Status) and status.code() == broker.SC.PeerAdded:
                LOG.debug('peered with controller %s:%s', self.controller_host,
                          self.controller_port)
                return True

            LOG.warning('broker endpoint status: %s', status)

            if i < attempts - 1:
                time.sleep(ZC_CONFIG.getfloat('client', 'connect_retry_delay_secs'))

        print('error: could not connect to controller {}:{}'.format(
            self.controller_host, self.controller_port))
        return False

    def publish(self, event):
        """Publishes the given event to the controller topic.

        Args:
            event (Event): the event to publish.
        """
        self.ep.publish(self.controller_topic, event)

    def receive(self, timeout_secs=None):
        """Receive an event from the controller's event subscriber.

        Args:
            timeout_secs (int): number of seconds before we time out.
                Has sematics of the poll.poll() timeout argument, i.e.
                None and negative values mean no timeout. The default
                is a 10-second timeout.

        Returns:
            A tuple of (1) an instance of one of the Event classes defined for
            the client, or None if timeout_secs passed before anything arrived,
            and (2) a string indicating any occurring errors. The string is
            empty when no error occurs.
        """
        timeout_msecs = timeout_secs or ZC_CONFIG.getint('client', 'request_timeout_secs')
        if timeout_msecs is not None:
            timeout_msecs *= 1000

        # XXX this is intentionally still very basic -- no event dispatch
        # mechanism, event loop, etc. The extent to which we require these will
        # become clearer soon. For now we just poll on the fds of the subscriber
        # and status subscriber so we get notified when something arrives or an
        # error occurs. Might have to handle POLLERR and POLLHUP here too to be
        # more robust still.
        while True:
            try:
                resps = self.poll.poll(timeout_msecs)
            except OSError as err:
                return None, 'polling error: {}'.format(err)

            if not resps:
                return None, 'connection timed out'

            for fdesc, event in resps:
                if fdesc == self.sub.fd() and event & select.POLLIN:
                    _, data = self.sub.get()

                    res = EventRegistry.make_event(data)
                    if res is not None:
                        return res, ''

                if fdesc == self.ssub.fd() and event & select.POLLIN:
                    status = self.ssub.get()
                    return None, 'status change: {}'.format(status)


class ConfigParserMixin():
    """A mixin that adds a method to create and represent the object via
    ConfigParser instances.
    """
    @classmethod
    def from_config_parser(cls, cfp, section=None): # pylint: disable=unused-argument
        """Instantiates an object of this class based on the given
        ConfigParser, and optional section name in it, as applicable.

        Raises ValueError if the provided configuration is invalid for the class
        to instantiate.
        """
        return None

    def to_config_parser(self, cfp=None): # pylint: disable=unused-argument
        """Returns this object in a ConfigParser instance. When the optional cfp
        argument is not None, the caller requests the implementation to add to
        the given parser, not create a new one.
        """
        return None

    @staticmethod
    def _get(cfp, typ, section, *keys):
        """Typed config key/val retrieval, with support for key name aliases."""
        for key in keys:
            val = cfp.get(section, key, fallback=None)
            if val is not None:
                try:
                    return typ(val)
                except ValueError as err:
                    raise ValueError('cannot convert item "{}" in section "{}" to type {}'
                                     .format(key, section, typ)) from err
        return None


class BrokerType:
    """Base class for types we can instantiate from or render to the
    Python-level Broker data model.

    See the Python type table and general Broker data model below for details:
    https://docs.zeek.org/projects/broker/en/current/python.html#data-model
    https://docs.zeek.org/projects/broker/en/current/data.html
    """
    def to_broker(self):
        """Returns a Broker-compatible rendition of this instance."""
        return None

    def to_json_data(self):
        """Returns JSON-suitable datastructure representing the object."""
        return self.__dict__

    @classmethod
    def from_broker(cls, broker_data): # pylint: disable=unused-argument
        """Returns an instance of the type given Broker data. Raises TypeError when the
        given data doesn't match the type's expectations."""
        return None


class BrokerEnumType(BrokerType, enum.Enum):
    """A specialization of Broker-based enums to bridge Broker/Python.

    This distinguishes the "flat" Python enums ("FOO") from the fully qualified
    way they're rendered via Zeek ("Some::Module::FOO"). To enable a Python enum
    to present the full qualification when sending into Broker, derivations
    reimplement the module_scope() class method.
    """
    def to_broker(self):
        scope = self.module_scope()
        scope = scope + '::' if scope else ''
        return broker.Enum(scope + self.name)

    def to_json_data(self):
        # A similar concern as above applies here, but the exact enum type will
        # often be clear from context and so the un-scoped name alone may
        # suffice.
        return self.name

    def qualified_name(self):
        scope = self.module_scope()
        scope = scope + '::' if scope else ''
        return scope + self.name

    @classmethod
    def lookup(cls, name):
        """Robust name-based lookup of an enum value.

        This removes any Zeek-land or Python-land qualifications, and
        automatically upper-cases the looked-up name.

        Raises KeyError if the requested enum value isn't defined.
        """
        name = name.split('::')[-1]
        name = name.split('.')[-1]
        return cls[name.upper()]

    @classmethod
    def module_scope(cls):
        # Reimplement this in derived classes to convey the Zeek-level enum
        # scope. For example, for a Foo.BAR (or Foo::BAR, in Zeek) enum value,
        # this should return the string "Foo".
        return ''

    @classmethod
    def from_broker(cls, broker_data):
        # The argument is a broker.Enum with a name property like Foo::VALUE.
        try:
            return cls.lookup(broker_data.name)
        except KeyError as err:
            raise TypeError('unexpected enum value for {}: {}'.format(
                cls.__name__, broker_data)) from err


class ClusterRole(BrokerEnumType):
    """Equivalent of Supervisor::ClusterRole enum in Zeek"""
    NONE = 0
    LOGGER = 1
    MANAGER = 2
    PROXY = 3
    WORKER = 4

    @classmethod
    def module_scope(cls):
        return 'Supervisor'


class ManagementRole(BrokerEnumType):
    """Equivalent of Management::Role enum in Zeek"""
    NONE = 0
    AGENT = 1
    CONTROLLER = 2
    NODE = 3

    @classmethod
    def module_scope(cls):
        return 'Management'


class State(BrokerEnumType):
    """Equivalent of Management::State enum in Zeek"""
    PENDING = 0
    RUNNING = 1
    STOPPED = 2
    FAILED = 3
    CRASHED = 4
    UNKNOWN = 5

    @classmethod
    def module_scope(cls):
        return 'Management'


class Option(BrokerType):
    """Equivalent of Management::Option."""
    def __init__(self, name, value):
        self.name = name
        self.value = value

    def to_broker(self):
        return (self.name, self.value)

    @classmethod
    def from_broker(cls, broker_data):
        try:
            return Option(*broker_data)
        except ValueError as err:
            raise TypeError('unexpected Broker data for Option object ({})'.format(
                broker_data)) from err


class Instance(BrokerType):
    """Equivalent of Management::Instance."""
    def __init__(self, name, addr=None, port=None):
        self.name = name
        # This is a workaround until we've resolved addresses in instances
        self.addr = addr or '0.0.0.0' # string or ipaddress type ... TBD
        self.port = port # None or integer value; we always mean TCP

    def __lt__(self, other):
        return self.name < other.name

    @classmethod
    def from_broker(cls, broker_data):
        try:
            name, addr, port = broker_data
            return Instance(name, addr, None if port is None else port.number())
        except ValueError as err:
            raise TypeError('unexpected Broker data for Instance object ({})'.format(
                broker_data)) from err

    def to_broker(self):
        port = None
        if self.port:
            port = broker.Port(int(self.port), broker.Port.TCP)
        return (self.name, ipaddress.ip_address(self.addr), port)


class Node(BrokerType, ConfigParserMixin):
    """Equivalent of Management::Node."""

    class HashableDict(dict):
        """Ad-hoc dict adaptation to work around the fact that we cannot readily put a
        dictionary into a set. We make a promise not to modify such dictionaries
        after hashing is needed."""
        def __hash__(self):
            return hash(frozenset(self))

    def __init__(self, name, instance, role, state=State.RUNNING, port=None,
                 scripts=None, options=None, interface=None, cpu_affinity=None,
                 env=None):
        self.name = name
        self.instance = instance
        self.role = role
        self.state = state
        self.port = port
        self.scripts = scripts
        self.options = options
        self.interface = interface
        self.cpu_affinity = cpu_affinity
        self.env = env or {}

    def __lt__(self, other):
        return self.name < other.name

    def to_broker(self):
        # Brokerization of the self.env dict poses a problem: Broker uses Python
        # sets to represent Broker sets, but Python sets cannot hash members
        # that have/are dicts. We work around this with a hashable dictionary
        # that we create only here, so won't modify after hashing.
        hdenv = Node.HashableDict(self.env.items())

        port = None
        if self.port is not None:
            port = broker.Port(self.port, broker.Port.TCP)

        return (self.name, self.instance,
                self.role.to_broker(),
                self.state.to_broker(),
                port,
                self.scripts,
                self.options,
                self.interface,
                self.cpu_affinity,
                hdenv)

    def to_json_data(self):
        return {
            'name': self.name,
            'instance': self.instance,
            'role': self.role.to_json_data(),

            # We currently omit the state field since it has no effect on
            # cluster node operation.
            # 'state': self.state.to_json_data(),

            'port': self.port,
            'scripts': self.scripts,
            'options': self.options,
            'interface': self.interface,
            'cpu_affinity': self.cpu_affinity,
            'env': self.env,
        }

    @classmethod
    def from_broker(cls, broker_data):
        try:
            options = None
            if broker_data[6] is not None:
                options = [Option.from_broker(opt_data) for opt_data in broker_data[6]]

            port = None
            if broker_data[4] is not None:
                port = broker_data[4].number()

            return Node(
                broker_data[0], # name
                broker_data[1], # instance
                ClusterRole.from_broker(broker_data[2]),
                State.from_broker(broker_data[3]),
                port,
                broker_data[5], # scripts
                options,
                broker_data[7], # interface
                broker_data[8], # cpu_affinity
                broker_data[9], # env
            )
        except ValueError as err:
            raise TypeError('unexpected Broker data for Node object ({})'.format(
                broker_data)) from err

    @classmethod
    def from_config_parser(cls, cfp, section=None):
        def get(typ, *keys):
            return cls._get(cfp, typ, section, *keys)

        name = section
        instance = get(str, 'instance')
        role = get(str, 'role', 'type')

        # We currently ignore the node state, if provided. The Node class
        # defaults to 'RUNNING'.
        state = State.RUNNING
        if get(str, 'state'):
            LOG.warning('ignoring node "%s" state "%s" in configuration',
                        name, get(str, 'state'))

        port = get(int, 'port')
        scripts = None

        # The Node record type on the Zeek side features a set[Options] that we
        # don't use (yet).

        interface = get(str, 'interface')
        cpu_affinity = get(int, 'cpu_affinity')
        env = None

        # Validate the specified values
        if not instance:
            raise ValueError('node "{}" requires an instance'.format(name))

        if not role:
            raise ValueError('node "{}" requires a role'.format(name))

        try:
            role = ClusterRole.lookup(role)
        except (AttributeError, KeyError) as err:
            raise ValueError('node "{}" role "{}" is invalid'.format(name, role)) from err

        # Optional values follow:

        if port is not None and (port < 1 or port > 65535):
            raise ValueError('node "{}" port "{}" is invalid'.format(name, port))

        try:
            # We support multiple scripts as a simple space-separated sequence
            # of filenames, with possible quotation marks for strings with
            # spaces. The shlex module provides a convenient way to parse these.
            val = get(str, 'scripts')
            if val:
                scripts = sorted(shlex.split(val))
        except (AttributeError, KeyError) as err:
            raise ValueError('node "{}" scripts value "{}" is invalid'.format(
                name, val)) from err

        try:
            # An environment variable dictionary is represented as a single
            # config value: a space-separated sequence of <var>=<val> strings,
            # possibly with quotation marks around the val. shlex helps here
            # too: shlex.split('foo=bar=baz blum="foo bar baz"') yields
            # ['foo=bar=baz', 'blum=foo bar baz']
            val = get(str, 'env')
            if val:
                env = {}
                for item in shlex.split(val):
                    key, kval = item.split('=', 1)
                    env[key] = kval
        except (AttributeError, KeyError, ValueError) as err:
            raise ValueError('node "{}" env value "{}" is invalid'.format(
                name, val)) from err

        return Node(name=name, instance=instance, role=role, state=state,
                    port=port, scripts=scripts, interface=interface,
                    cpu_affinity=cpu_affinity, env=env)

    def to_config_parser(self, cfp=None):
        if cfp is None:
            cfp = configparser.ConfigParser(allow_no_value=True)

        if self.name in cfp.sections():
            cfp.remove_section(self.name)

        cfp.add_section(self.name)

        cfp.set(self.name, 'instance', self.instance)
        cfp.set(self.name, 'role', self.role.name)

        # Skip state for the moment, it has no operational effect
        # if self.state is not None:
        #    cfp.set(self.name, 'state', self.state.name)

        if self.port is not None:
            cfp.set(self.name, 'port', str(self.port))

        if self.scripts:
            # See if any of the script paths contain spaces, and use quotation
            # marks if so. This does not escape quotation marks or deal with
            # other "difficult" characters.
            scripts = []

            for script in sorted(self.scripts):
                if len(script.split()) > 1:
                    script = '"' + script + '"'
                scripts.append(script)

            cfp.set(self.name, 'scripts', ' '.join(scripts))

        if self.interface is not None:
            cfp.set(self.name, 'interface', self.interface)

        if self.cpu_affinity is not None:
            cfp.set(self.name, 'cpu_affinity', str(self.cpu_affinity))

        if self.env:
            # If the value has whitespace, use key="val". As with scripts above,
            # this does not deal with more complicated escaping/characters.
            env = []

            for key in sorted(self.env.keys()):
                val = self.env[key]
                if len(val).split() > 1:
                    val = '"' + val + '"'

                env.append('{}={}'.format(key, val))

            cfp.set(self.name, 'env', ' '.join(env))

        return cfp


class Configuration(BrokerType, ConfigParserMixin):
    """Equivalent of Management::Configuration."""
    def __init__(self):
        self.id = make_uuid()
        self.instances = []
        self.nodes = []

    @classmethod
    def from_broker(cls, broker_data):
        res = Configuration()
        res.id = broker_data[0]
        for inst_data in broker_data[1]:
            res.instances.append(Instance.from_broker(inst_data))
        for node_data in broker_data[2]:
            res.nodes.append(Node.from_broker(node_data))
        return res

    def to_broker(self):
        """Marshal the configuration to a Broker-compatible layout.

        Broker's data format uses tuples for records, so we go through the
        defined instances and nodes to convert, when they're not None.
        """
        instances = {inst.to_broker() for inst in self.instances}
        nodes = {node.to_broker() for node in self.nodes}

        return (self.id, instances, nodes)

    def to_json_data(self):
        return {
            "id": self.id,
            "instances": [inst.to_json_data() for inst in sorted(self.instances)],
            "nodes": [node.to_json_data() for node in sorted(self.nodes)],
        }

    @classmethod
    def from_config_parser(cls, cfp, _section=None):
        config = Configuration()

        for section in cfp.sections():
            if section == 'instances':
                # The [instances] section is special: each key in it is the name of
                # an instance, each val is the host:port pair where its agent is
                # listening. The val may be absent when it's an instance that
                # connects to the controller.
                for key, val in cfp.items('instances'):
                    if not val:
                        config.instances.append(Instance(key))
                    else:
                        hostport = val
                        parts = hostport.split(':', 1)
                        if len(parts) != 2:
                            LOG.warning('invalid instance "%s" spec "%s", skipping', key, val)
                            continue
                        config.instances.append(Instance(key, parts[0].strip(), parts[1].strip()))
                continue

            # All keys for sections other than "instances" need to have a value.
            for key, val in cfp.items(section):
                if val is None:
                    LOG.error('Config item %s/%s needs a value', section, key)
                    return None

            # The other sections are cluster nodes. Each section name corresponds to
            # a node name, with the keys being one of "type", "instance", etc.
            if section in [node.name for node in config.nodes]:
                LOG.warning('node "%s" defined more than once, skipping repeats"', section)
                continue

            try:
                config.nodes.append(Node.from_config_parser(cfp, section))
            except ValueError as err:
                LOG.warning('invalid node "%s" spec, skipping: "%s"', section, err)

        return config

    def to_config_parser(self, cfp=None):
        if cfp is None:
            cfp = configparser.ConfigParser(allow_no_value=True)

        if 'instances' in cfp.sections():
            cfp.remove_section('instances')

        if self.instances:
            cfp.add_section('instances')
            for inst in sorted(self.instances):
                cfp.set('instances', inst.name, '{}:{}'.format(inst.addr, inst.port))

        for node in sorted(self.nodes):
            node.to_config_parser(cfp)

        return cfp


class NodeStatus(BrokerType):
    """Equivalent of Management::NodeState."""
    def __init__(self, node, state, mgmt_role, cluster_role, pid=None, port=None):
        self.node = node # A string containing the name of the node
        self.state = state # A State enum value
        self.mgmt_role = mgmt_role # A ManagementRole enum value
        self.cluster_role = cluster_role # A ClusterRole enum value
        self.pid = pid # A numeric process ID
        self.port = port # A numeric (TCP) port

    def __lt__(self, other):
        return self.node < other.node

    @classmethod
    def from_broker(cls, broker_data):
        # When a listening port is available, convert Broker's native port type
        # to a plain integer. We're always dealing with TCP ports here.
        port = broker_data[5].number() if broker_data[5] is not None else None

        return NodeStatus(
            broker_data[0],
            State.from_broker(broker_data[1]),
            ManagementRole.from_broker(broker_data[2]),
            ClusterRole.from_broker(broker_data[3]),
            broker_data[4],
            port)


class Result(BrokerType):
    """Equivalent of Management::Result."""
    def __init__(self, reqid, instance, success=True, data=None, error=None, node=None):
        self.reqid = reqid
        self.instance = instance
        self.success = success
        self.data = data
        self.error = error
        self.node = node

    def __lt__(self, other):
        """Support sorting. Sort first by instance name the result comes from, second by
        the node name if present.
        """
        if self.instance < other.instance:
            return True
        if self.instance > other.instance:
            return False

        # Be more specific if we have a node name -- we can use it to sort when
        # two results come from the same instance.
        if self.node is not None and other.node is not None:
            return self.node < other.node

        return False

    @classmethod
    def from_broker(cls, broker_data):
        return Result(*broker_data)

# Command handlers

def cmd_get_config(controller, args):
    controller.publish(events.GetConfigurationRequest(make_uuid()))
    resp, msg = controller.receive()

    if resp is None:
        LOG.error('No response received: %s', msg)
        return 1

    if not isinstance(resp, events.GetConfigurationResponse):
        LOG.error('Received unexpected event: %s', resp)
        return 1

    res = Result.from_broker(resp.result)

    if not res.success:
        msg = res.error if res.error else 'no reason given'
        print_error('failure: {}'.format(msg))
        return 1

    if not res.data:
        LOG.error('Received result did not contain configuration data: %s', resp)
        return 1

    config = Configuration.from_broker(res.data)

    with open(args.filename, 'w') if args.filename and args.filename != '-'  else sys.stdout as hdl:
        if args.as_json:
            hdl.write(json_dumps(config.to_json_data()) + '\n')
        else:
            cfp = config.to_config_parser()
            cfp.write(hdl)

    return 0


def cmd_get_id_value(controller, args):
    controller.publish(events.GetIdValueRequest(make_uuid(), args.id, set(args.nodes)))
    resp, msg = controller.receive()

    if resp is None:
        LOG.error('No response received: %s', msg)
        return 1

    if not isinstance(resp, events.GetIdValueResponse):
        LOG.error('Received unexpected event: %s', resp)
        return 1

    json_data = {
        'results': {},
        'errors': [],
    }

    # The Result records have both instance and node filled in, so use both for
    # ordering. While for the JSON serialization we can outsource the ordering
    # task to Python, for our error reporting it's up to us, and we want be
    # reproducible.

    results = [Result.from_broker(broker_data) for broker_data in resp.results]

    for res in sorted(results):
        if not res.success:
            json_data['errors'].append({
                'source': res.node,
                'error': res.error,
            })
            continue

        # Upon success, we should always have res.node filled in. But guard anyway.
        if res.node:
            # res.data is a string containing JSON rendered by Zeek's to_json()
            # BiF. Parse it into a data structure to render seamlessly.
            try:
                json_data['results'][res.node] = json.loads(res.data)
            except json.JSONDecodeError as err:
                json_data['errors'].append({
                    'source': res.node,
                    'error': 'JSON decode error: {}'.format(err),
                })
            continue

        json_data['errors'].append({
            'error': 'result lacking node: {}'.format(res.data),
        })

    print(json_dumps(json_data))
    return 0 if len(json_data['errors']) == 0 else 1


def cmd_get_instances(controller, args): # pylint: disable=unused-argument
    controller.publish(events.GetInstancesRequest(make_uuid()))
    resp, msg = controller.receive()

    if resp is None:
        LOG.error('No response received: %s', msg)
        return 1

    if not isinstance(resp, events.GetInstancesResponse):
        LOG.error('Received unexpected event: %s', resp)
        return 1

    res = Result.from_broker(resp.result)

    if not res.success:
        msg = res.error if res.error else 'no reason given'
        print_error('failure: {}'.format(msg))
        return 1

    if res.data is None:
        LOG.error('Received result did not contain instance data: %s', resp)
        return 1

    json_data = {}

    # res.data is a (possibly empty) vector of Instances. Make the list of
    # instances easier to comprehend than raw Broker data: turn it into Instance
    # objects, then render these JSON-friendly.
    try:
        for inst in sorted([Instance.from_broker(inst) for inst in res.data]):
            json_data[inst.name] = inst.to_json_data()
            json_data[inst.name].pop('name')
    except TypeError as err:
        LOG.error('Instance data invalid: %s', err)

    print(json_dumps(json_data))
    return 0


def cmd_get_nodes(controller, _args):
    controller.publish(events.GetNodesRequest(make_uuid()))
    resp, msg = controller.receive()

    if resp is None:
        LOG.error('No response received: %s', msg)
        return 1

    if not isinstance(resp, events.GetNodesResponse):
        LOG.error('Received unexpected event: %s', resp)
        return 1

    json_data = {
        'results': {},
        'errors': [],
    }

    results = [Result.from_broker(broker_data) for broker_data in resp.results]

    for res in sorted(results):
        if not res.success:
            json_data['errors'].append({
                'source': res.instance,
                'error': res.error,
            })
            continue

        if res.data is None:
            json_data['errors'].append({
                'source': res.instance,
                'error': 'result does not contain node status data',
            })
            continue

        json_data['results'][res.instance] = {}

        # res.data is a NodeStatusVec
        try:
            nstats = [NodeStatus.from_broker(nstat_data) for nstat_data in res.data]
            for nstat in sorted(nstats):
                # If either of the two role enums are "NONE", we make them
                # None. That way they stay in the reporting, but are more easily
                # distinguished from "actual" values.
                mgmt_role = nstat.mgmt_role if nstat.mgmt_role != ManagementRole.NONE else None
                cluster_role = nstat.cluster_role if nstat.cluster_role != ClusterRole.NONE else None

                json_data['results'][res.instance][nstat.node] = {
                    'state': nstat.state,
                    'mgmt_role': mgmt_role,
                    'cluster_role': cluster_role,
                }

                if nstat.pid is not None:
                    json_data['results'][res.instance][nstat.node]['pid'] = nstat.pid
                if nstat.port is not None:
                    json_data['results'][res.instance][nstat.node]['port'] = nstat.port
        except TypeError as err:
            LOG.error('NodeStatus data invalid: %s', err)
            LOG.debug(traceback.format_exc())

    print(json_dumps(json_data))
    return 0 if len(json_data['errors']) == 0 else 1


def cmd_monitor(controller, args): # pylint: disable=unused-argument
    while True:
        resp, msg = controller.receive(None)

        if resp is None:
            print('no response received: {}'.format(msg))
        else:
            print('received "{}"'.format(resp))

    return 0


def cmd_set_config(controller, args):
    if not args.config or (args.config != '-' and not os.path.isfile(args.config)):
        print_error('Please provide a cluster configuration file. See --help for details.')
        return 1

    # We use a config parser to parse the cluster configuration. For instances,
    # we allow names without value to designate agents that connect to the
    # controller, like this:
    #
    # [instances]
    # foobar
    #
    # All other keys must have a value.
    config = Configuration()
    cfp = configparser.ConfigParser(allow_no_value=True)

    if args.config == '-':
        cfp.read_file(sys.stdin)
    else:
        cfp.read(args.config)

    config = Configuration.from_config_parser(cfp)

    # XXX todo: validate basic properties of the configuration

    # Okay, we have a cluster configuration. Ship it:

    controller.publish(events.SetConfigurationRequest(make_uuid(), config.to_broker()))
    resp, msg = controller.receive()

    if resp is None:
        LOG.error('No response received: %s', msg)
        return 1

    if not isinstance(resp, events.SetConfigurationResponse):
        LOG.error('Received unexpected event: %s', resp)
        return 1

    retval = 0

    for broker_data in resp.results:
        res = Result.from_broker(broker_data)
        if not res.success:
            msg = ': ' + res.error if res.error else ''
            print_error('instance {} failure{}'.format(res.instance, msg))
            retval = 1

    return retval


def cmd_show_settings(_controller, _args):
    ZC_CONFIG.write(sys.stdout)
    return 0


def cmd_test_timeout(controller, args):
    controller.publish(events.TestTimeoutRequest(make_uuid(), args.with_state))
    resp, msg = controller.receive()

    if resp is None:
        print_error('no response received: {}'.format(msg))
        return 1

    if not isinstance(resp, events.TestTimeoutResponse):
        print_error('received unexpected event: {}'.format(resp))
        return 1

    res = Result.from_broker(resp.result)
    outcome = 'success' if res.success else 'failure'
    error = res.error if res.error else '(none)'

    print_error('response is {}, error string: {}'.format(outcome, error))
    return 0


# Utility functions

def make_uuid(prefix=''):
    """Helper to make a UUID in string form."""
    return prefix + str(uuid.uuid1())


# Broker's basic types aren't JSON-serializable, so patch that up
# in this json.dumps() wrapper for JSON serialization of any object:
def json_dumps(obj):
    def default(obj):
        if isinstance(obj, ipaddress.IPv4Address):
            return str(obj)
        if isinstance(obj, ipaddress.IPv6Address):
            return str(obj)
        if isinstance(obj, broker.Port):
            return str(obj)
        if isinstance(obj, BrokerEnumType):
            return obj.to_json_data()
        raise TypeError('cannot serialize {} ({})'.format(type(obj), str(obj)))

    indent = 2 if ZC_CONFIG.getboolean('client', 'pretty_json') else None
    return json.dumps(obj, default=default, sort_keys=True, indent=indent)


def print_error(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def create_parser():
    parser = argparse.ArgumentParser(description='A zeek-client prototype')
    parser.add_argument('-c', '--configfile', metavar='FILE', default=ZC_CONFIG_FILE,
                        help='Path to zeek-client config file. (Default: {})'.format(ZC_CONFIG_FILE))
    parser.add_argument('--controller', metavar='HOST:PORT', default=ZC_CONTROLLER,
                        help='Address and port of the controller, either of '
                        'which may be omitted (default: {})'.format(ZC_CONTROLLER))
    arg = parser.add_argument('--set', metavar='SECTION.KEY=VAL', action='append', default=[],
                              help='Adjust a configuration setting. Can use repeatedly.')

    if 'argcomplete' in sys.modules:
        arg.completer = ZC_CONFIG.completer

    parser.add_argument('--verbose', '-v', action='count', default=0,
                        help='Increase program output for debugging.'
                        ' Use multiple times for more output (e.g. -vvv).')
    parser.add_argument('--version', action='store_true',
                        help='Show version number and exit.')

    command_parser = parser.add_subparsers(
        title='commands', dest='command',
        help='See `%(prog)s <command> -h` for per-command usage info.')

    sub_parser = command_parser.add_parser(
        'get-config', help='Retrieve deployed cluster configuration.')
    sub_parser.set_defaults(run_cmd=cmd_get_config)
    sub_parser.add_argument('--filename', '-f', metavar='FILE', default='-',
                            help='Output file for the configuration, default stdout')
    sub_parser.add_argument('--as-json', action='store_true',
                            help='Report in JSON instead of INI-style config file')

    sub_parser = command_parser.add_parser(
        'get-id-value', help='Show the value of a given identifier in Zeek cluster nodes.')
    sub_parser.set_defaults(run_cmd=cmd_get_id_value)
    sub_parser.add_argument('id', metavar='IDENTIFIER',
                            help='Name of the Zeek script identifier to retrieve.')
    sub_parser.add_argument('nodes', metavar='NODES', nargs='*', default=[],
                            help='Name(s) of select Zeek cluster nodes to query.'
                            ' When omitted, queries all nodes.')

    sub_parser = command_parser.add_parser(
        'get-instances', help='Show instances connected to the controller.')
    sub_parser.set_defaults(run_cmd=cmd_get_instances)

    sub_parser = command_parser.add_parser(
        'get-nodes', help='Show active Zeek nodes at each instance.')
    sub_parser.set_defaults(run_cmd=cmd_get_nodes)

    sub_parser = command_parser.add_parser(
        'monitor', help='For troubleshooting: do nothing, just report events.')
    sub_parser.set_defaults(run_cmd=cmd_monitor)

    sub_parser = command_parser.add_parser(
        'set-config', help='Deploy cluster configuration.')
    sub_parser.set_defaults(run_cmd=cmd_set_config)
    sub_parser.add_argument('config', metavar='FILE',
                            help='Cluster configuration file, "-" for stdin')

    sub_parser = command_parser.add_parser(
        'show-settings', help="Show zeek-client's own configuration.")
    sub_parser.set_defaults(run_cmd=cmd_show_settings)

    sub_parser = command_parser.add_parser(
        'test-timeout', help='Send timeout test event.')
    sub_parser.set_defaults(run_cmd=cmd_test_timeout)
    sub_parser.add_argument('--with-state', action='store_true',
                            help='Make request stateful in the controller.')

    if 'argcomplete' in sys.modules:
        argcomplete.autocomplete(parser)

    return parser


def configure_logger(args):
    if args.verbose == 0:
        return

    formatter = logging.Formatter(
        '%(asctime)s %(levelname)-8s %(message)s', '%Y-%m-%d %H:%M:%S')
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)

    LOG.setLevel(logging.ERROR)

    if args.verbose == 1:
        LOG.setLevel(logging.WARNING)
    elif args.verbose == 2:
        LOG.setLevel(logging.INFO)
    elif args.verbose >= 3:
        LOG.setLevel(logging.DEBUG)

    LOG.addHandler(handler)


def main():
    # Preliminary configuration update: environment variables can already take
    # hold. This allows autocompleted settings to show values more accurately
    # than our hardwired defaults.
    ZC_CONFIG.update_from_env()

    parser = create_parser()
    args = parser.parse_args()

    # After we've parsed the command line, finalize config settings in the
    # expected hierarchical order:
    ZC_CONFIG.update_from_file(args.configfile)
    ZC_CONFIG.update_from_env()
    ZC_CONFIG.update_from_args(args)

    if args.version:
        print(ZC_VERSION)
        return 0

    configure_logger(args)

    controller_parts = args.controller.split(':', 1)

    if len(controller_parts) != 2:
        # Allow just a host, falling back to default port
        controller_parts = [controller_parts[0], ZC_CONTROLLER_PORT]
    elif not controller_parts[0]:
        # Allow just a port (as ":<port>"), falling back to default host.
        controller_parts = [ZC_CONTROLLER_HOST, controller_parts[1]]

    controller_host = controller_parts[0]

    try:
        controller_port = int(controller_parts[1])
        if controller_port < 1 or controller_port > 65535:
            raise ValueError
    except ValueError:
        print_error('error: controller port number invalid')
        return 1

    controller = Controller(controller_host, controller_port)
    if not controller.connect():
        return 1

    if not args.command:
        print_error('error: please provide a command to execute. See --help.')
        return 1

    try:
        return args.run_cmd(controller, args)
    except KeyboardInterrupt:
        return 0


if __name__ == '__main__':
    sys.exit(main())
